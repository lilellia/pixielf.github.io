<html>

<head>
    <title>
        Mana Khemia: Deconstruction
    </title>
    <link href="https://fonts.googleapis.com/css?family=Tangerine" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet" />
    <link href="style.css" rel="stylesheet" />
    <link rel="icon" href="../favicon.png" type="image/x-icon">

    <link href="../prism.css" rel="stylesheet">
</head>

<body style="font-family: Montserrat, sans-serif;">
    <script src="../prism.js"></script>

    <h1>Mana Khemia: Deconstruction</h1>
    <p>
        This is an analysis of the NTSC-U PS2 version of the .iso file for <i>Mana Khemia: Alchemists of Al-Revis</i>.
    </p>

    <h2>I: Extracting the Archive</h2>

    <p>
        ...This was actually really easy, just a simple command in the terminal:
    </p>
    <pre><code class="language-bash">$ 7z x 'Mana Khemia - Alchemists of Al-Revis (USA).iso' -oManaKhemia</code></pre>

    <p>
        From there, we can see what the project folder looks like:
    </p>
    <button type="button" id="manakhemia-treeview" class="collapsible">$ManaKhemia/ folder view</button>
    <div class="content">
    <pre><code class="language-treeview">ManaKhemia/
|-- MODULES/
|   `-- IOPRP310.IMG
|-- MOVIE/
|   |-- A9_ED.SFD
|   |-- A9_EDB.SFD
|   |-- A9_OP.SFD
|   |-- AVAN.SFD
|   |-- AVANJ.SFD
|   `-- SCHOOL.SFD
|-- SOUND/
|   |-- SSE/
|       `-- SSE.AFS
|   `-- STREAM
|       `-- STREAM.AFS
|-- VPACK/
|   |-- V00000.AFS
|   |-- V01000.AFS
|   |-- V02000.AFS
|   |-- V03000.AFS
|   |-- V04000.AFS
|   |-- V05000.AFS
|   |-- V06000.AFS
|   |-- V07000.AFS
|   |-- V08000.AFS
|   |-- V09000.AFS
|   |-- V10000.AFS
|   `-- V11000.AFS
|-- VPACKJ/
|   |-- V00000.AFS
|   |-- V01000.AFS
|   |-- V02000.AFS
|   |-- V03000.AFS
|   |-- V04000.AFS
|   |-- V05000.AFS
|   |-- V06000.AFS
|   |-- V07000.AFS
|   |-- V08000.AFS
|   |-- V09000.AFS
|   |-- V10000.AFS
|   `-- V11000.AFS
|-- RPK.BIN
|-- SLUS_217.35
`-- SYSTEM.CNF</code></pre>
</div>

    <!-- STEP 2 -->
    <h2>II: Investigating the MOVIE folder</h2>
    <p>
        I can't be bothered to deal with the <code>MODULES/IOPRP310.IMG</code> file thanks to its extension, but I <i>can</i> be bothered to look at the <code>MOVIE</code> folder. Perhaps unsurprisingly, VLC is more than happy to open the *.SFD files, though that isn't to say that it plays them without issue. In particular, it <i>does</i> play, but the playhead tracking is completely messed up. I'd also initially believed that the audio was held elsewhere as the couple clips I tried were silent, but I eventually decided to just blindly convert them to *.mp4 files instead:
    </p>
    <pre><code class="language-bash">$ManaKhemia/MOVIE$ for f in *.SFD; do ffmpeg -i "$f" "${f/%.SFD/.mp4}"; done
$ManaKhemia/MOVIE$ ls *.mp4
A9_EDB.mp4  A9_ED.mp4  A9_OP.mp4  AVANJ.mp4  AVAN.mp4  SCHOOL.mp4</code></pre>

    <p>
        I clipped the ffmpeg output, but there weren't any errors, and this fixed both of the problems: the videos play normally AND with sound. And what I found is:
    </p>
    <table>
        <tr>
            <th>File</th>
            <th>Scene</th>
            <th>Length</th>
        </tr>
        <tr>
            <td>A9_ED.mp4</td>
            <td>credits</td>
            <td>3:45</td>
        </tr>
        <tr>
            <td>A9_EDB.mp4</td>
            <td>credits roll (without audio/animations)</td>
            <td>3:45</td>
        </tr>
        <tr>
            <td>A9_OP.mp4</td>
            <td>the opening animation before the title screen (where <i>Run for Your Life</i> plays)</td>
            <td>2:00</td>
        </tr>
        <tr>
            <td>AVAN.mp4</td>
            <td>the opening scene where Vayne meets Sulpher (immediately after selecting New Game)</td>
            <td>0:55</td>
        </tr>
        <tr>
            <td>AVANJ.mp4</td>
            <td>the same scene, but with JA audio</td>
            <td>0:55</td>
        </tr>
        <tr>
            <td>SCHOOL.mp4</td>
            <td>the establishing shots of Al-Revis that plays during the Orientation sequence</td>
            <td>1:25</td>
        </tr>
    </table>
    <p>
        Nothing too crazy, but it's interesting to me just how few pre-rendered cutscenes there are. And the Vayne-Sulpher opening is one of them—none of the chapter opening scenes (Theofratus, Sulpher, and/or Isolde) scenes are. Which makes sense given that this first one is the only such scene where the text doesn't appear in the normal textboxes, but it was still something I noticed.
    </p>

    <h2>III: Investigating the SOUND folder</h2>
    <p>What strikes me as odd ehre is that there are two subfolders, each with only a single file (whose name matches the folder itself). This could easily have been <code>SOUND/SSE.AFS</code> and <code>SOUND/STREAM.AFS</code>, but... whatever. Given the name of the folder, I think it's safe to assume that these are audio files, but I've never heard of *.AFS files. Presumably, it's some sort of compression/archive file.</p>
    <p>
        Spurred on by the success of VLC and ffmpeg in the previous step, I tried just using those, but neither of them were very happy with it. I tried importing it as Raw Audio in Audacity with the default settings but was greeted by nothing by ear-piercing terribleness. So... it seems like I'm going to have to figure out what's going on—according to <a href="https://en.wikipedia.org/wiki/ADX_(file_format)">Wikipedia</a>:
    </p>
    <p style="margin-left: 5%; font-style: italic;">
        ADX is a lossy proprietary audio storage and compression format developed by CRI Middleware specifically for use in video games; it is derived from ADPCM. Its most notable feature is a looping function that has proved useful for background sounds in various games that have adopted the format, including many games for the Sega Dreamcast as well as some PlayStation 2, GameCube and Wii games. One of the first games to use ADX was Burning Rangers, on the Sega Saturn. Notably, the Sonic the Hedgehog series from the Dreamcast generation up to at least Shadow the Hedgehog have used this format for sound and voice recordings.</p>

    <p style="margin-left: 5%; font-style: italic;">
        On top of the main ADPCM encoding, the ADX toolkit also includes a sibling format, AHX, which uses a variant of MPEG-2 audio intended specifically for voice recordings and <b>a packaging archive, AFS, for bundling multiple ADX and AHX tracks into a single container file</b>.
    </p>
    <p>
        The article goes on to describe the technical specification for the ADX format, but since we're looking at an AFS file, that's not much help at the moment. That's... fine, I guess. The article also links to a <a href="https://web.archive.org/web/20090318103258/http://www.geocities.co.jp/Playtown/2004/dcdev/index.html">very old website</a> (a 2009 wayback-machine snapshot of a Geocities page) with <a href="https://web.archive.org/web/20110927091814/http://www.geocities.co.jp/Playtown/2004/dcdev/adx2wav02.lzh">source code for an AFS extractor</a>. Downloading the code and inspecting it—
    </p>
    <pre><code class="language-bash">Downloads$ 7z l adx2wav02.lzh | tail -9
Date      Time    Attr         Size   Compressed  Name
------------------- ----- ------------ ------------  ------------------------
2001-01-24 17:21:26 .....         3835         1504  adx2wav.c
2001-01-24 17:29:02 .....        11546         3792  adx2wav.exe
2001-01-24 17:30:52 .....          979          627  adx2wav.txt
2000-12-17 09:55:36 .....         1323          640  afs_extract.c
2000-12-17 09:55:40 .....        11041         3233  afs_extract.exe
------------------- ----- ------------ ------------  ------------------------
2001-01-24 17:30:52              28724         9796  5 files</code></pre>
    <p>
        —shows it to be some good 'ol C code with what seem to be prepacked Windows executables. I was, of course, running this on Linux, so I just rebuilt the executables myself rather than bothering with WINE. The .txt file is a bit of a garbled mess, but it is enough to let us know that the script grabs the name of the file from argv, so we can run
    </p>
    <pre><code class="language-bash">Downloads/adx2wav02$ gcc -o afs_extract afs_extract.c
Downloads/adx2wav02$ ./afs_extract $ManaKhemia/SOUND/SSE/SSE.AFS</code></pre>
    
    <p>which didn't seem to do anything useful. Both the <code>adx2wav02</code> and <code>$ManaKhemia/SOUND/SSE</code> folders were unchanged, and the only thing printed was <code>$ManaKhemia/SOUND/SSE/SSE.AFS - 0</code>, which... isn't super helpful. Looking at the C code, it seemed to be output by this line:</p>
    <pre><code class="language-c">printf("%s - %d\n",name,n);</code></pre>
    <p>which indicated that <code>n==0</code>, which is a problem for the <code>for(i=0;i&lt;n;i++) { ... }</code> loop that starts a few lines later, given that this seems to be the loop that actually pulls the <code>n</code> ADX files out of the archive.</p>

    <h2>III (Part II): Translating C to Python</h2>
    <p>
        In order to get a better handle on this code, since there was obviously something happening (though, admittedly, it was probably with the AFS file itself), I began to port the code over to Python 3, which is a language I actually know.
    </p>
    <p>
        The main function is almost trivial, but I really had to figure out the rest of the C code. Of course, it wasn't commented at all, so here's my annotated version:
    </p>

    <button type="button" id="annotated-c-code" class="collapsible">afs_extract.c (annotated)</button>
    <div class="content">
    <pre><code class="language-c">int afs_extract(char *name) {
    // This section just establishes a bunch of variables,
    // which I don't need to deal with in Python.
    FILE *fp,*out;
    int i,n;
    char buf[0x8000];

    struct {
        char id[4];
        long num;
    } hdr;

    struct {
        long offset;
        long size;
    } *idx;

    char basename[256],*p;

    // assign the value of `name` to `basename`
    // ...which we can do with a simple assignment in Python
    strcpy(basename,name);

    // strrchr is weird, but we immediately reassign p anyway
    // whenever it isn't null, and I can't actually find where
    // it would get used, so... I'm just going to ignore it
    p = strrchr(basename,'.');
    if (p) *p=0;

    // open the target file in "rb" mode, and, on error, return -1
    fp = fopen(name,"rb");
    if (fp==NULL) return -1;

    /* fread(*ptr, size, nmemb, *stream)
     * ---------------------------------
     * reads data from `stream` into the array pointed to by `ptr`
     * `size` = size (bytes) of each element to be read
     * `nmemb` = number of elements, each of size `size`
     *
     * In this way, we read 8 chunks of 1 byte each from `fp`
     * (the AFS file) and write them into `hdr`
     *
     * Because of the struct defining `hdr`, the first four bytes
     * should end up as hdr.id (interpreted as a string), and the
     * remaining four as hdr.num (interpreted as a long).
    */
    fread(&hdr,1,8,fp);

    // We compare hdr.id to the literal string "AFS" and if we get
    // a value other than zero (the strings don't match), we close
    // the file and complain that it's not a proper AFS file.
    if (memcmp(hdr.id,"AFS",4)) {
        fclose(fp);
        printf("not AFS\n");
        return -1;
    }

    // at this point, we needlessly assign n = hdr.num
    n = hdr.num;

    // This outputs the file we're extracting from and the number
    // of ADX files contained within it.
    printf("%s - %d\n",name,n);

    // allocate enough space in `idx` for n copies of the struct
    // containing the offset and size data?
    idx = malloc(sizeof(*idx)*n);

    // as before, use fread to read from `fp`: here, we read
    // n blocks of 8 bytes each, assigning them into `idx`
    fread(idx,8,n,fp);

    // now, we loop through each of these ADX "header" structs
    for(i=0;i&lt;n;i++) {
        int size;
        char outfile[256];

        // assign outfile as the name of the destination ADX file
        // indexed by number of the loop
        sprintf(outfile,"%s_%02d.adx",basename,i);

        // actually open this file in "wb" mode
        out = fopen(outfile,"wb");

        /* fseek(*stream, offset, whence)
         * ------------------------------
         * set the file position of `stream` to a position of `offset`,
         * relative to `whence`
         *
         * In this case, we seek to idx[i].offset: the offset of the current
         * adx file, and whence=SEEK_SET, meaning that we seek from the
         * beginning of the file (absolute seeking).
        */
        fseek(fp,idx[i].offset,SEEK_SET);

        // needlessly alias idx[i].size, but this is the size of the
        // ADX data
        size = idx[i].size;

        // output {destination} {offset} {size}
        printf("%s %08x %08x\n",outfile,idx[i].offset,size);

        // while we still have to data to read for this file
        while(size) {
            // figure out how much to read, capped by the size of the
            // buffer we established earlier.
            int rsize = size&lt;sizeof(buf)?size:sizeof(buf);

            // then actually read that many bytes into the buffer
            rsize = fread(buf,1,rsize,fp);

            // and write it to the outfile
            fwrite(buf,1,rsize,out);

            // decrement the amount we still have let to read
            size-=rsize;
        }

        // close the output file
        fclose(out);
    }

    // and clean up some stuff down here too
    free(idx);
    fclose(fp);
    return -1;
}
    </code></pre>
    </div>
    <p>
        Which I turned into this Python (3.6+) script:
    </p>

    <button type="button" id="afs-extract-python" class="collapsible">afs_extract.py</button>
    <div class="content">
    <pre><code class="language-python">
import collections
import pathlib
import sys


def afs_extract(filepath: pathlib.Path):
    with open(filepath, 'rb') as afs:
        # read 8 bytes from file, with the first four bytes
        # being hdr.id, and the last four bytes being the
        # number of ADX files in the archive
        HDR = collections.namedtuple('HDR', ('id', 'num'))
        hdr = HDR(
            id=afs.read(4),
            # assuming little endian because the sample AFS file
            # I'm working with gives this as "CF 00 00 00", which
            # is 207 with little endian and 3,472,883,712 with big
            # endian, which... just feels too big.
            num=int.from_bytes(afs.read(4), 'little')
        )

        # We compare hdr.id to the literal bytestring b'AFS\x00'
        # and when these don't match, we close the file and complain
        # that it's not a proper AFS file.
        if hdr.id != b'AFS\x00':
            sys.exit('Not an AFS file')

        # output the file we're extracting from and the number of
        # ADX blocks contained within it
        print(f'{filepath} - {hdr.num} ADX blocks')

        # read blocks of 8 bytes each, assigning them into `idx`
        ADXHeader = collections.namedtuple('ADXHeader', ('offset', 'size'))
        idx = [
            ADXHeader(
                offset=int.from_bytes(afs.read(4), 'little'),
                size=int.from_bytes(afs.read(4), 'little')
            )
            for _ in range(hdr.num)
        ]

        # now, we loop through each of these ADX "header" structs
        for i, header in enumerate(idx):
            # assign outfile as the path of the destination ADX file
            # indexed by the number of the loop, then open it in "wb"
            # mode
            outfile = filepath.with_name(f'{filepath.stem}_{i:03}.adx')

            with open(outfile, 'wb') as adx:
                # set the file position of the input stream according
                # to the data in the header
                afs.seek(header.offset)

                # output {destination} {offset} {size}
                print(f'{str(outfile):&lt;50} offset=0x{header.offset:08X} size=0x{header.size:08X}')

                # read the necessary number of bytes into memory
                # and write it out to the adx file
                adx.write(afs.read(header.size))


if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        sys.exit('DreamCast AFS extract ADX')

    for filename in sys.argv[1:]:
        path = pathlib.Path(filename).resolve()
        afs_extract(path)
    </code></pre>
    </div>

    <p>
        Running it via
    </p>
    <pre><code class="language-bash">$ python3 $ManaKhemia/SOUND/SSE/SSE.AFS</code></pre>

    <p>
        gave me <code>$ManaKhemia/SOUND/SSE/SSE_{000-206}.adx</code> to play with. I wasn't initially sure that these files would be workable at all since I had to make an assumption about how the data should be read into the <code>idx</code> struct (to get offset and size): I <i>assumed</i> that they each get four bytes (since we were reading in eight), but that was essentially a guess.
    </p>

    <h2>III (Part III): Converting ADX files to something usable</h2>

    <p style="margin-left: 5%; font-style: italic;">
        As noted earlier, AHX is just an implementation of MPEG2 audio and the decoding method is basically the same as the standard, it is possible just to demux the stream from the ADX container and feed it through a standard MPEG Audio decoder like mpg123. The ADX header's "sample rate" and "total samples" are usually correct if a decoder needs them (so should be set by encoder/muxer implementations) but most of the other fields such as the "block size" and "sample bitdepth" will usually be zero — as noted above, the looping functionality is also unavailable.
    </p>

    <p>Funnily enough, I was really about to go through all of the conversion processes myself (because the Wikipedia article gave the specification), but I found this paragraph hiding at the bottom of the article and just decided to test the ADX files in VLC, which... again, perhaps unsurprisingly, worked just fine. Some ffmpeg-ing later, I had them all as .ogg files:</p>

    <pre><code class="language-bash">$ManaKhemia/SOUND/SSE$ for f in *.adx; do ffmpeg -i "$f" "${f/%.adx/.ogg}"; rm "$f"; done</code></pre>

    <p>
        That's easy to add to the Python script, which I also went ahead and added a little bit of QOL features, so running this <a href="afs_extract.py">updated Python script</a>—
    </p>
    <pre><code class="language-bash">$ python3 afs_extract.py $ManaKhemia/SOUND/SSE/SSE.AFS $ManaKhemia/SOUND/STREAM/STREAM.AFS --convert-ogg --delete-adx</code></pre>

    <p>
        —resulted in 207 files in <code>$ManaKhemia/SOUND/SSE</code> and another 117 in <code>$ManaKhemia/SOUND/STREAM</code>. The former group was mostly sound effects that I didn't know how to trace, so I <a href="mkdata.html#sound-data-stream">analyzed the stream files.</a> I definitely couldn't get all of them, and there were quite a few that I recognized but could <i>quite</i> place, so that'll be a running project as I play through the game again.
    </p>

    <h2>IV: VPACK and VPACKJ</h2>

    <p style="margin-left: 5%; font-size: italic;">Hey, look! The files in these two folders are <i>also</i> .AFS files, which I've just spent a bunch of time trying to figure out how to decode!</p>

    <p>
        This one was simple enough to unpack:
    </p>
<pre><code class="language-bash">$ python3 afs_extract.py $ManaKhemia/VPACK/*.AFS --convert-ogg --delete-adx
$ python3 afs_extract.py $ManaKhemia/VPACKJ/*.AFS --convert-ogg --delete-adx
</code></pre>

    <p>
        Okay, well, there's 1000 ADX files in each of those AFS files, so the folders get a bit bloated, but that's easy enough to fix:
    </p>
<pre><code class="language-bash">$ManaKhemia/VPACK$ for i in $(seq -w 00 11); do mkdir V${i}000; mv V${i}000_*.ogg V${i}000/; done</code></pre>

    <p>
        This places them in a folder according to which AFS file they came from. It's still 1000 files in each folder, but at least it's not 11000 files in one folder.
    </p>

</body>

<script>
    let collapsible = document.getElementsByClassName("collapsible");
    for (let i = 0; i < collapsible.length; i++) {
        collapsible[i].addEventListener("click", function () {
            this.classList.toggle("active");
            let content = this.nextElementSibling;
            if (content.style.display === "block") {
                content.style.display = "none";
            } else {
                content.style.display = "block";
            }
        });
    }
</script>

</html>